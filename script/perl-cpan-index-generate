#!perl
use v5.40;

use Getopt::Long::Parser;
use IO::Compress::Gzip ();
use IO::File;
use JSON::XS;
use Path::Tiny;

my $VERSION = v0.0.1;

my $HELP = <<'EOF';
Usage: perl-cpan-index-generate [options] dir

Options:
  -i, --include   include packages
  -e, --exclude   exclude packages
  -o, --output    output file (default: STDOUT)
  -g, --gzip      turn on gzip compression
      --header    header text
  -h, --help      show help
  -v, --version   show version

Examples:
  ❯ perl-cpan-index-generate --exclude Test::Simple,ExtUtils::MakeMaker ./local/lib/perl5
  ❯ perl-cpan-index-generate --include URI,LWP ./local/lib/perl5
EOF

package Index {
    sub new ($class, %argv) {
        bless { json => JSON::XS->new, index => [], %argv }, $class;
    }
    sub load ($self, $dir) {
        my sub visit ($path, $state) {
            return if $path !~ /install\.json$/;
            my $install = $self->{json}->decode($path->slurp);

            for my $package (keys $install->{provides}->%*) {
                return if exists $self->{exclude}{$package};
            }
            if ($self->{include}->%*) {
                my $found;
                for my $package (keys $install->{provides}->%*) {
                    exists $self->{include}{$package} and $found++;
                }
                return if !$found;
            }
            for my ($package, $option) ($install->{provides}->%*) {
                push $self->{index}->@*, {
                    package => $package,
                    version => $option->{version},
                    pathname => $install->{pathname},
                };
            }
        }
        Path::Tiny->new($dir)->visit(\&visit, { recurse => 1 });
    }
    sub write ($self, $fh) {
        $fh->print($self->{header}, "\n\n");
        for my $index (sort { lc $a->{package} cmp lc $b->{package} } $self->{index}->@*) {
            $fh->printf("%s %s %s\n",
                $index->{package}, $index->{version} || 'undef', $index->{pathname},
            );
        }
    }
}

my $parser = Getopt::Long::Parser->new(config => ['no_auto_abbrev', 'no_ignore_case', 'bundling']);
$parser->getoptionsfromarray(\@ARGV,
    "header=s" => \(my $header = "# This file was generated by perl-cpan-index-generate."),
    "i|include=s" => \my $include,
    "e|exclude=s" => \my $exclude,
    "o|output=s" => \my $output,
    "g|gzip" => \my $gzip,
    "h|help" => sub (@) { die $HELP },
    "v|version" => sub (@) { printf "v%vd\n", $VERSION; exit },
) or exit 1;

my $dir = shift;
die "error: need DIRECTORY argument\n" if !$dir;
die "error: '$dir' is not a directory\n" if !-d $dir;

my %include = map { ($_, 1) } split /,/, ($include || "");
my %exclude = map { ($_, 1) } split /,/, ($exclude || "");

my $fh = $output ? IO::File->new($output, "w") : \*STDOUT;
if ($gzip) {
    $fh = IO::Compress::Gzip->new($fh, -Level => 9, Minimal => 1);
}

my $index = Index->new(header => $header, include => \%include, exclude => \%exclude);
$index->load($dir);
$index->write($fh);
